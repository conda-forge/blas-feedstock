{% set version = "3.9.0" %}
# if build_num is reset to 0 (for new version), update increment for blas_minor below
{% set build_num = 8 %}
{% set version_major = version.split(".")[0] %}
{% set blas_major = "2" %}
# make sure we do not create colliding version strings of output "blas"
# for builds across lapack-versions within the same blas_major
{% set blas_minor = build_num + 100 %}

# blas_major denotes major infrastructural change to how blas is managed
package:
  name: blas-split
  version: "{{ version }}"

source:
  url: https://github.com/Reference-LAPACK/lapack/archive/v{{ version }}.tar.gz
  sha256: 106087f1bb5f46afdfba7f569d0cbe23dacb9a07cd24733765a0e89dbe1ad573
  patches:
    # Test BLAS and LAPACKE in addition to LAPACK
    - patches/0001-Test-BLAS-and-LAPACKE-in-addition-to-LAPACK.patch
    # Only the test-suite is compiled here, and we therefore do not need to
    # carry all the patches that the lapack-feedstock has (see comment below)

build:
  number: "{{ build_num }}"

requirements:
  build:
    - {{ compiler("c") }}               # [unix]
    - {{ compiler("fortran") }}         # [unix]
    - {{ compiler("m2w64_c") }}         # [win]
    - {{ compiler("m2w64_fortran") }}   # [win]
    - cmake
    - m2-make   # [win]
    - make      # [not win]
    - posix     # [win]
    # The following are actual build dependencies of this recipe; however, they
    # only get installed by the build scripts, since they must be installed in a
    # different environment (otherwise there'd be a variant collision)! The build
    # script will link to those netlib libraries and set up the netlib test suite.
    # For the different blas variants, build_pkg.{sh|bat} will then point those
    # links to the respective libraries of the desired variant, and *then* run
    # the test suite (in test_blas.{sh|bat}) to see that everything works correctly.
    # Note: These libraries are built in the lapack-feedstock.
    # - libblas    {{ version }} *netlib
    # - libcblas   {{ version }} *netlib
    # - liblapack  {{ version }} *netlib
    # - liblapacke {{ version }} *netlib

outputs:
  - name: libblas
    script: build_pkg.sh     # [unix]
    script: build_pkg.bat    # [win]
    build:
      string: "{{ build_num }}_{{ blas_impl }}"
      run_exports:
        - {{ pin_subpackage("libblas", max_pin="x") }}
      track_features:
       - blas_{{ blas_impl }}  # [blas_impl != blas_default_impl]
    requirements:
      host:
        - libopenblas 0.3.12   # [blas_impl == 'openblas']
        # 3.9.0 is supported from mkl 2020.4
        - mkl 2020.4           # [blas_impl == 'mkl']
        - blis 0.8.0           # [blas_impl == 'blis']
      run:
        - {{ pin_compatible("libopenblas", max_pin="x.x.x", exact=win) }}  # [blas_impl == 'openblas']
        - {{ pin_compatible("mkl", max_pin="x", exact=win) }}              # [blas_impl == 'mkl']
        - {{ pin_compatible("blis", max_pin="x.x.x", exact=win) }}         # [blas_impl == 'blis']
      run_constrained:
        - {{ pin_subpackage("libcblas", exact=True) }}
        - {{ pin_subpackage("liblapack", exact=True) }}
        - {{ pin_subpackage("liblapacke", exact=True) }}
        - blas * {{ blas_impl }}
    files:
      - lib/libblas.so                          # [linux]
      - lib/libblas.so.{{ version_major }}      # [linux]
      - lib/libblas.dylib                       # [osx]
      - lib/libblas.{{ version_major }}.dylib   # [osx]
      - Library/bin/libblas.dll                 # [win]
    test:
      commands:
        # Following line is just to help conda-build's used variables detection
        - echo hello  # [blas_impl_lib == 'blas']
        - test -f $PREFIX/lib/libblas.so                          # [linux]
        - test -f $PREFIX/lib/libblas.so.{{ version_major }}      # [linux]
        - test -f $PREFIX/lib/libblas.dylib                       # [osx]
        - test -f $PREFIX/lib/libblas.{{ version_major }}.dylib   # [osx]
        - if not exist %LIBRARY_BIN%/libblas.dll exit 1           # [win]

  - name: libcblas
    script: build_pkg.sh     # [unix]
    script: build_pkg.bat    # [win]
    build:
      string: "{{ build_num }}_{{ blas_impl }}"
      run_exports:
        - {{ pin_subpackage("libcblas", max_pin="x") }}
      track_features:
       - blas_{{ blas_impl }}     # [blas_impl != blas_default_impl]
    requirements:
      host:
        - {{ pin_subpackage("libblas", exact=True) }}
      run:
        - {{ pin_subpackage("libblas", exact=True) }}
      run_constrained:
        - {{ pin_subpackage("liblapack", exact=True) }}
        - {{ pin_subpackage("liblapacke", exact=True) }}
        - blas * {{ blas_impl }}
    files:
      - lib/libcblas.so                          # [linux]
      - lib/libcblas.so.{{ version_major }}      # [linux]
      - lib/libcblas.dylib                       # [osx]
      - lib/libcblas.{{ version_major }}.dylib   # [osx]
      - Library/bin/libcblas.dll                 # [win]
    test:
      commands:
        - test -f $PREFIX/lib/libcblas.so                          # [linux]
        - test -f $PREFIX/lib/libcblas.so.{{ version_major }}      # [linux]
        - test -f $PREFIX/lib/libcblas.dylib                       # [osx]
        - test -f $PREFIX/lib/libcblas.{{ version_major }}.dylib   # [osx]
        - if not exist %LIBRARY_BIN%/libcblas.dll exit 1           # [win]

  # blis does not provide liblapack(e) - repackage netlib-version to have consistent
  # build strings (see build_pkg.{bat|sh}); otherwise, testing blis becomes difficult
  # since conda-build would get confused by the mix of exact pins and netlib subpackages
  - name: liblapack
    script: build_pkg.sh     # [unix]
    script: build_pkg.bat    # [win]
    build:
      string: "{{ build_num }}_{{ blas_impl }}"                      # [blas_impl != "blis"]
      string: "{{ build_num }}_netlib_repacked_for_{{ blas_impl }}"  # [blas_impl == "blis"]
      run_exports:
        - {{ pin_subpackage("liblapack", max_pin="x.x") }}
      track_features:
       - blas_{{ blas_impl }}     # [blas_impl != blas_default_impl]
    requirements:
      host:
        - {{ pin_subpackage("libblas", exact=True) }}
      run:
        - {{ pin_subpackage("libblas", exact=True) }}
      run_constrained:
        - {{ pin_subpackage("libcblas", exact=True) }}
        - {{ pin_subpackage("liblapacke", exact=True) }}
        - blas * {{ blas_impl }}
    files:
      - lib/liblapack.so                          # [linux]
      - lib/liblapack.so.{{ version_major }}      # [linux]
      - lib/liblapack.dylib                       # [osx]
      - lib/liblapack.{{ version_major }}.dylib   # [osx]
      - Library/bin/liblapack.dll                 # [win]
    test:
      commands:
        - test -f $PREFIX/lib/liblapack.so                          # [linux]
        - test -f $PREFIX/lib/liblapack.so.{{ version_major }}      # [linux]
        - test -f $PREFIX/lib/liblapack.dylib                       # [osx]
        - test -f $PREFIX/lib/liblapack.{{ version_major }}.dylib   # [osx]
        - if not exist %LIBRARY_BIN%/liblapack.dll exit 1           # [win]

  - name: liblapacke
    script: build_pkg.sh     # [unix]
    script: build_pkg.bat    # [win]
    build:
      string: "{{ build_num }}_{{ blas_impl }}"                      # [blas_impl != "blis"]
      string: "{{ build_num }}_netlib_repacked_for_{{ blas_impl }}"  # [blas_impl == "blis"]
      run_exports:
        - {{ pin_subpackage("liblapacke", max_pin="x.x") }}
      track_features:
       - blas_{{ blas_impl }}     # [blas_impl != blas_default_impl]
    requirements:
      host:
        - {{ pin_subpackage("libblas", exact=True) }}
        - {{ pin_subpackage("libcblas", exact=True) }}
        - {{ pin_subpackage("liblapack", exact=True) }}
      run:
        - {{ pin_subpackage("libblas", exact=True) }}
        - {{ pin_subpackage("libcblas", exact=True) }}
        - {{ pin_subpackage("liblapack", exact=True) }}
      run_constrained:
        - blas * {{ blas_impl }}
    files:
      - lib/liblapacke.so                          # [linux]
      - lib/liblapacke.so.{{ version_major }}      # [linux]
      - lib/liblapacke.dylib                       # [osx]
      - lib/liblapacke.{{ version_major }}.dylib   # [osx]
      - Library/bin/liblapacke.dll                 # [win]
    test:
      commands:
        - test -f $PREFIX/lib/liblapacke.so                          # [linux]
        - test -f $PREFIX/lib/liblapacke.so.{{ version_major }}      # [linux]
        - test -f $PREFIX/lib/liblapacke.dylib                       # [osx]
        - test -f $PREFIX/lib/liblapacke.{{ version_major }}.dylib   # [osx]
        - if not exist %LIBRARY_BIN%/liblapacke.dll exit 1           # [win]

  - name: blas-devel
    # uses lapack {{ version }}, not {{ blas_major }}
    script: install_blas_devel.sh   # [unix]
    build:
      string: "{{ build_num }}_{{ blas_impl }}"
    requirements:
      host:
        - openblas   # [blas_impl == "openblas"]
        - mkl-devel  # [blas_impl == "mkl"]
      run:
        - openblas   # [blas_impl == "openblas"]
        - mkl-devel  # [blas_impl == "mkl"]
        - {{ pin_subpackage("blas", exact=True) }}
    test:
      commands:
        - test -f $PREFIX/lib/pkgconfig/blas.pc                     # [unix and blas_impl == "openblas"]
        - test -f $PREFIX/lib/liblapack.so                          # [linux]
        - test -f $PREFIX/lib/liblapack.dylib                       # [osx]
        - if not exist %LIBRARY_BIN%/liblapack.dll exit 1           # [win]


  # For conda-forge blas selector, see also lapack-feedstock
  - name: blas
    version: "{{ blas_major }}.{{ blas_minor }}"
    script: test_blas.sh   # [unix]
    script: test_blas.bat  # [win]
    build:
      string: "{{ blas_impl }}"
      activate_in_script: True
    requirements:
      build:
        - {{ compiler('c') }}                 # [unix]
        - {{ compiler('fortran') }}           # [unix]
        - {{ compiler('m2w64_c') }}           # [win]
        - {{ compiler('m2w64_fortran') }}     # [win]
        - cmake
        - m2-make       # [win]
        - posix         # [win]
        - llvm-openmp   # [linux and ((blas_impl == "openblas") or (blas_impl == "mkl"))]
      host:
        - {{ pin_subpackage("libblas", exact=True) }}
        - {{ pin_subpackage("libcblas", exact=True) }}
        - {{ pin_subpackage("liblapack", exact=True) }}
        - {{ pin_subpackage("liblapacke", exact=True) }}
      run:
        - {{ pin_subpackage("libblas", exact=True) }}
        - {{ pin_subpackage("libcblas", exact=True) }}
        - {{ pin_subpackage("liblapack", exact=True) }}
        - {{ pin_subpackage("liblapacke", exact=True) }}
    test:
      commands:
        - test -f $PREFIX/lib/liblapacke.so                          # [linux]
        - test -f $PREFIX/lib/liblapacke.so.{{ version_major }}      # [linux]
        - test -f $PREFIX/lib/liblapacke.dylib                       # [osx]
        - test -f $PREFIX/lib/liblapacke.{{ version_major }}.dylib   # [osx]
        - if not exist %LIBRARY_BIN%/liblapacke.dll exit 1           # [win]

about:
  home: https://github.com/conda-forge/blas-feedstock
  license: BSD-3-Clause
  license_file:
    - LICENSE.txt
    - {{ blas_impl }}_license.txt  # [win]
  summary: Metapackage to select the BLAS variant. Use conda's pinning mechanism in your environment to control which variant you want.

extra:
  recipe-maintainers:
    - jakirkham
    - pelson
    - isuruf
    - ocefpaf
    - h-vetinari
